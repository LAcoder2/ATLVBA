// ATLVBA.idl: источник языка IDL для ATLVBA
//

// Этот файл будет обработан средством MIDL для
// создание библиотеки типов ($handlersafeidlname$.tlb) и кода маршалирования.

import "oaidl.idl";
import "ocidl.idl";

//import "ATLVBA64.idl";
[
	uuid(566442d4-10d6-4437-b9d4-836bd6a64c04),
	version(1.0)
]
library ATLVBALib
{
	importlib("stdole2.tlb");
	typedef [public] void AnyType;
	//import "helper.idl";
	//cpp_quote("#include \"Constants.h\"")
	typedef enum CompareMethod {
		BinaryCompare = 0,
		TextCompare = 1
	} CompareMethod;
	//[
	//	dllname("<no entry points>"),
	//	//uuid(343DB180-2BCC-1069-8215-00DD010EDFAA)
	//]
	module ConstModule {
		const __int3264 NullPtr = 0;	
	//#if difined(_WIN64)
		const long ptrSz = 0x00000004;
		const long varSz = 0x00000016;
	//#else
		//const long long ptrSz = 0x00000008;
		//const long long varSz = 0x00000024;
	//#endif
		const LPSTR lpstrStr = "HIJ"; //автоматически конвертируется в UTF-16
		const BSTR bstrStr = L"XYZ"; //для bstr обязательно надо указывать L
		//const LPWSTR wstrStr = L"IFG"; //не поддерживаемый automation тип
		//const unsigned char ansiStr[] = "ABC"; //поддерживается Asc("ansiStr")

	};
	
	[
		uuid(9300AA31-2722-453F-9140-1082D95E486D),
		dllname("ATLVBA.dll"),
		hidden
	]
	module MemHelp{
		[entry("VarPtr")] __int3264 vp([in] void* Var);
		[entry("VarPtr")] __int3264 ap([in] SAFEARRAY(void)* Arr);
		[entry("VarPtr")] __int3264 ArrPtr([in] const SAFEARRAY(void)* Arr);
		
		[entry("GetMemPtr")] void GetMemPtr(const void* src, void* dst);
		[entry("GetMem1")] void GetMem1(const void* src, void* dst);
		[entry("GetMem2")] void GetMem2(const void* src, void* dst);
		[entry("GetMem4")] void GetMem4(const void* src, void* dst);
		[entry("GetMem8")] void GetMem8(const void* src, void* dst);
		[entry("GetMem16")] void GetMem16(const void* src, void* dst);
		[entry("GetMemVT")] void GetMemVT(const void* src, void* dst);		
		
		[entry("PutMemPtr")] void PutMemPtr(void* dst, __int3264 src);
		[entry("PutMem1")] void PutMem1(void* dst, byte src);
		[entry("PutMem2")] void PutMem2(void* dst, short src);
		[entry("PutMem4")] void PutMem4(void* dst, long src);
		[entry("PutMem8")] void PutMem8(void* dst, CY src);
		[entry("PutMem8")] void PutMemLL(void* dst, __int64 src);
		[entry("PutMemVT")] void PutMemVT(void* dst, VARIANT src);

		[entry("GetMem1"), propget]
		HRESULT __stdcall GetByt([in] void* Src, [out, retval] byte* bRetVal);
		[entry("PutMem1"), propput]
		HRESULT __stdcall PutByt([in] void* Dst, [in] byte bNewVal);

		[entry("GetMem2"), propget]
		HRESULT __stdcall GetInt([in] void* Src, [out, retval] short* iRetVal);
		[entry("PutMem2"), propput]
		HRESULT __stdcall PutInt([in] void* Dst, [in] short iNewVal);

		[entry("GetMem4"), propget]
		HRESULT __stdcall GetLng([in] void* Src, [out, retval] int* lRetVal);
		[entry("PutMem4"), propput]
		HRESULT __stdcall PutLng([in] void* Dst, [in] int lNewVal);

		[entry("GetMemPtr"), propget, helpstring("Returns or sets the value referenced by the source parameter cast to a DWord Long.")]
		HRESULT __stdcall GetPtr([in] void* Src, [out, retval] __int3264* pRetVal);
		[entry("PutMemPtr"), propput, ]
		HRESULT __stdcall PutPtr([in] void* Dst, [in] __int3264 pNewVal);
		
		//[entry("GetMemPtr"), propget]
		//HRESULT __stdcall StringPtr([in] BSTR* Src, [out, retval] __int3264* pRetVal);
		//[entry("VarPtr"), propget]
		//HRESULT __stdcall SPtr([in] BSTR Src, [out, retval] __int3264 pRetVal);
		[entry("PutMemPtr"), propput]
		HRESULT __stdcall PutStrPtr([in] BSTR* Src, [in] __int3264 pNewVal);
		
		[entry("GetMemPtr"), propget]
		HRESULT __stdcall SAPtr([in] SAFEARRAY(void)* Array, [out, retval] __int3264* pRetVal);
		[entry("PutMemPtr"), propput]
		HRESULT __stdcall SAPtr([in] SAFEARRAY(void)* Array, [in] __int3264 pNewVal);
		
		//[entry("GetMemPtr"), propget]
		//HRESULT __stdcall StrSAPtr([in] SAFEARRAY(BSTR)* Array, [out, retval] __int3264* lpRetVal);
		//[entry("PutMemPtr"), propput, ]
		//HRESULT __stdcall StrSAPtr([in] SAFEARRAY(BSTR)* Array, [in] __int3264 NewValue);

		[entry("GetMem8"), propget]
		HRESULT __stdcall GetCur([in] void* Src, [out, retval] CURRENCY* cRetVal);
		[entry("PutMem8"), propput]
		HRESULT __stdcall PutCur([in] void* Dst, [in] CURRENCY cNewVal);
		[entry("GetMem8"), propget]
		HRESULT __stdcall GetDbl([in] void* Src, [out, retval] double* dRetVal);
		[entry("PutMem8"), propput]
		HRESULT __stdcall PutDbl([in] void* Dst, [in] double dNewVal);
		
		[entry("MovePtr")] void MovePtr(void* dst, void* src);
		[entry("MovePtr"), helpstring("Перемещает только указатель SA, не заботясь о данных массива dst (предполагается, что он пустой)")] 
		void MoveAryPtr(SAFEARRAY(void)* dst, SAFEARRAY(void)* src);
		[entry("MoveAry"), helpstring("Безопасное перемещение массива, с освобождением массива назначения")] void MoveAry(SAFEARRAY(void)* dst, SAFEARRAY(void)* src);
		[entry("MoveStr"), helpstring("Безопасное перемещение строки, с освобождением строки назначения")] void MoveStr(BSTR* dst, BSTR* src);
		[entry("MoveVT"), helpstring("Безопасное перемещение варианта")] void MoveVT(void* dst, void* src);
		
		[entry("SwapPtr")] void SwapPtr(void* var1, void* var2);
		[entry("SwapPtr")] void SwapAry(SAFEARRAY(void)* var1, SAFEARRAY(void)* var2);
		[entry("SwapVT")] void SwapVT(VARIANT* var1, VARIANT* var2);

		[entry("memCmp")] long __stdcall memCmp(const void* Buf1, void* Buf2, __int3264 Size);
		[entry("memCpy")] __int3264 __stdcall memCpy(void* dst, void* src, __int3264 sz);
		[entry(3)] __int3264 memmem([in] void* pbTarget, [in] long cbTarget, [in] void* pbPattern, [in] long cbPattern);
		[entry("MemFindRev")] __int3264 MemFindRev([in] void* pWhere, [in] int szWhere, [in] void* pWhat, [in] int szWhat);
		[entry("MemFindRevW")] __int3264 MemFindRevW([in] void* pWhere, [in] int szWhere, [in] void* pWhat, [in] int szWhat);
	};
	module StrHelp{
		[entry("StrLen")] INT32 StrLen([in] BSTR str);
		[entry("StrLenB")] INT32 StrLenB([in] BSTR str);
		[entry("ArrLen")] INT32 ArrLen([in] SAFEARRAY(void)* Arr);
		[entry("ToAnsi")] BSTR ToAnsi([in] BSTR str);
		[entry("ToAnsi"), helpstring("Alias ToAnsi")] BSTR toA([in] BSTR str);
		[entry("FromAnsi")] BSTR FromAnsi([in] BSTR str);
		[entry("FromAnsi"), helpstring("Alias FromAnsi")] BSTR fmA([in] BSTR str);
		[entry("InStrB_")]
		INT32 InStrB_([in] int Start, [in] BSTR Where, [in] BSTR What);
		[entry("InStrB2")] 
		INT32 InStrB2([in] int Start, [in] BSTR Where, [in] BSTR What, [in] int Length);
		[entry("InStrB3")] 
		INT32 InStrB3([in] int Start, [in] BSTR Where, [in] BSTR What, [in] int lStop);
		[entry("InStrByt"), helpstring("Analogue of the InStrB function for byte arrays")]
		INT32 InStrByt([in] int Start, [in] SAFEARRAY(byte)* Where, [in] SAFEARRAY(byte)* What);
		[entry("InStrByt2")] 
		INT32 InStrByt2([in] int Start, [in] SAFEARRAY(byte)* Where, [in] SAFEARRAY(byte)* What, [in] int Length);
		[entry("InStrByt3")] 
		INT32 InStrByt3([in] int Start, [in] SAFEARRAY(byte)* Where, [in] SAFEARRAY(byte)* What, [in] int lStop);
		[entry("InStrRevB")] 
		long InStrRevB([in] BSTR psCheck, [in] BSTR psMatch, 
			[in, optional, defaultvalue(0)] long Start, 
			[in, optional, defaultvalue(BinaryCompare)] CompareMethod Compare);
		[entry("InStrRevB2")] 
		long InStrRevB2([in] BSTR psCheck, [in] BSTR psMatch,
			[in, optional, defaultvalue(0)] long Start, [in, optional, defaultvalue(0)] long Length, 
			[in, optional, defaultvalue(BinaryCompare)] CompareMethod Compare);
		[entry("InStrRevB3")]
		long InStrRevB3([in] BSTR psCheck, [in] BSTR psMatch,
			[in, optional, defaultvalue(0)] long Start, [in, optional, defaultvalue(0)] long EndFind,
			[in, optional, defaultvalue(BinaryCompare)] CompareMethod Compare);
		[entry("ToUTF8")] BSTR ToUTF8([in] const BSTR sInp);
		[entry("ToUTF8"), helpstring("Alias ToUTF8")] BSTR toU8([in] const BSTR sInp);
		[entry("FromUTF8")] BSTR FromUTF8([in] const BSTR sInp);
		[entry("FromUTF8"), helpstring("Alias FromUTF8")] BSTR fmU8([in] const BSTR sInp);
		[entry("UCaseA")] BSTR UCaseA([in] const BSTR psInp);
		[entry("LCaseA")] BSTR LCaseA([in] const BSTR psInp);
		[entry("StartsWith")] VARIANT_BOOL StartsWith(BSTR sWhere, BSTR sWhat);
		[entry("EndsWith")] VARIANT_BOOL EndsWith(BSTR sWhere, BSTR sWhat);
		[entry("StartsWithAry")] VARIANT_BOOL StartsWithByt(SAFEARRAY(byte)* Where, SAFEARRAY(byte)* What);
		[entry("EndsWithAry")] VARIANT_BOOL EndsWithByt(SAFEARRAY(byte)* Where, SAFEARRAY(byte)* What);
		[entry("StartsWithAry")] VARIANT_BOOL StartsWithInt(SAFEARRAY(short)* Where, SAFEARRAY(short)* What);
		[entry("EndsWithAry")] VARIANT_BOOL EndsWithInt(SAFEARRAY(short)* Where, SAFEARRAY(short)* What);
	};
	module ArrHelp{		
		[entry("isObjInit")] VARIANT_BOOL isArrayInit([in] SAFEARRAY(void)* Arr);		
		[entry("AssignVecV")]void AssignVecV(
			[in, out] SAFEARRAY(VARIANT)* arDst,
			[in] SAFEARRAY(VARIANT)* arSrc);
		[entry("AssignVecV"), propput, vararg]
		HRESULT __stdcall GroupAssigment(
			[in, out] SAFEARRAY(VARIANT)* ArgList, 
			[in, out] SAFEARRAY(VARIANT)* rhs);
		[entry("GetRefList"), propget, vararg]
		HRESULT __stdcall RefList(	
			[in, out] SAFEARRAY(VARIANT)* ArgList, 
			[out, retval] SAFEARRAY(VARIANT)* pOut);
		/*interface _Class1 : IDispatch {
			[id(0x68030001), propput, vararg]
			HRESULT PutRefList(
				[in, out] SAFEARRAY(VARIANT)* Dst,
				[in, out] SAFEARRAY(VARIANT)* rhs);
			[id(0x68030000), propget, vararg]
			HRESULT GetRefList(
				[in] long pAr,
				[in, out] SAFEARRAY(VARIANT)* ArgList,
				[out, retval] SAFEARRAY(VARIANT)*);
		};*/
		/*[entry("InitCallBack")] void InitCallBack(__int3264 pfn);
		[entry("TestProp"), propput, vararg]
		HRESULT __stdcall TestProp(
			[in, out] SAFEARRAY(VARIANT)* ArgList,
			[in, out] SAFEARRAY(VARIANT)* rhs);*/
	};
	module BitHelp{
		[entry("GetBit")] VARIANT_BOOL __stdcall GetBit(int num, unsigned char pos);
		[entry("SetBit")] int __stdcall SetBit(int num, unsigned char pos);
		[entry("ClearBit")] int __stdcall ClearBit(int num, unsigned char pos);
		[entry("LeftBitShift"), helpstring("num << shift")]
		int __stdcall LeftBitShift(int num, unsigned char shift);
		[entry("RightBitShift"), helpstring("num >> shift")]
		int __stdcall RightBitShift(int num, unsigned char shift);
		[entry("BitRotateLeft"), helpstring("левое битовое вращение")]
		int __stdcall BitRotateLeft(int num, unsigned char shift);
		[entry("BitRotateRight"), helpstring("правое битовое вращение")]
		int __stdcall BitRotateRight(int num, unsigned char shift);
		[entry("BitCount"), helpstring("кол-во установленных битов")]
		unsigned char __stdcall BitCount(int num);
		[entry("ExtractBits"), helpstring("Извлечь биты с позиции start длиной length. Пример: ExtractBits(0xABCD, 4, 8) -> извлечёт 0xBC")]
		int __stdcall ExtractBits(int n, int start, int length);
		[entry("SetBits"), helpstring("Установить биты из n с позиции 'start' длиной 'length' в значение 'value'")]
		int __stdcall SetBits(int n, unsigned char start, unsigned char length, int value);

		[entry("GetBit64"), helpstring("")]
		VARIANT_BOOL __stdcall GetBit64(__int64 num, unsigned char pos);
		[entry("SetBit64"), helpstring("")]
		__int64 __stdcall SetBit64(__int64 num, unsigned char pos);
		[entry("ClearBit64"), helpstring("")]
		__int64 __stdcall ClearBit64(__int64 num, unsigned char pos);
		[entry("LeftBitShift64"), helpstring("")]
		__int64 __stdcall LeftBitShift64(__int64 num, unsigned char shift);
		[entry("RightBitShift64"), helpstring("")]
		__int64 __stdcall RightBitShift64(__int64 num, unsigned char shift);
		[entry("BitRotateLeft64"), helpstring("")]
		__int64 __stdcall BitRotateLeft64(__int64 num, unsigned char shift);
		[entry("BitRotateRight64"), helpstring("")]
		__int64 __stdcall BitRotateRight64(__int64 num, unsigned char shift);
		[entry("BitCount64"), helpstring("")]
		unsigned char __stdcall BitCount64(__int64 num);
		[entry("ExtractBits64"), helpstring("")]
		__int64 __stdcall ExtractBits64(__int64 n, __int64 start, __int64 length);
		[entry("SetBits64"), helpstring("")]
		__int64 __stdcall SetBits64(__int64 n, unsigned char start, unsigned char length, __int64 value);

		[entry("IsEven"), helpstring("Проверка четности")]
		BOOL __stdcall IsEven(int n);
		[entry("IsOdd"), helpstring("Проверка нечетности")]
		BOOL __stdcall IsOdd(int n);	// Нечётное
		[entry("IsAligned"), helpstring("Проверка выравнивания адреса. alignment должно быть степенью двойки")]
		BOOL __stdcall IsAligned(void* ptr, size_t alignment);
		[entry("IsPowerOfTwo"), helpstring("Проверка, является ли число степенью двойки")]
		BOOL __stdcall IsPowerOfTwo(int n);
		[entry("LowestSetBit"), helpstring("Поиск самого младшего установленного бита\nПример: 12 (1100) & -12 (0100) = 4 (0100)")]
		int __stdcall LowestSetBit(int n);
		[entry("HighestSetBit_msvc"), helpstring("поиск самого старшего установленного бита")]
		int __stdcall HighestSetBit(int n);
	};
	module ZipHelp{
		[entry("UnzipFileToBytes")] 
			SAFEARRAY(byte) __stdcall 
			UnzipFileToBytes(BSTR sFilePath, BSTR sZipPath);
	};
	[hidden]
	module CallHelp{
		[entry("Call0")] void __stdcall Call0([in] __int3264 fn, [in, out] void* ret, [in] int retSz);
		[entry("Call1")] void __stdcall Call1([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1);
		[entry("Call2")] void __stdcall Call2([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2);
		[entry("Call3")] void __stdcall Call3([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3);
		[entry("Call4")] void __stdcall Call4([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4);
		[entry("Call5")] void __stdcall Call5([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4, void* a5);
		[entry("Call6")] void __stdcall Call6([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4, void* a5, void* a6);
		[entry("Call7")] void __stdcall Call7([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4, void* a5, void* a6, void* a7);
		[entry("Call8")] void __stdcall Call8([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4, void* a5, void* a6, void* a7, void* a8);
		[entry("Call9")] void __stdcall Call9([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4, void* a5, void* a6, void* a7, void* a8, void* a9);
		[entry("Call10")] void __stdcall Call10([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4, void* a5, void* a6, void* a7, void* a8, void* a9, void* a10);
		
		[entry("CCall0")] void __stdcall CCall0([in] __int3264 fn, [in, out] void* ret, [in] int retSz);
		[entry("CCall1")] void __stdcall CCall1([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1);
		[entry("CCall2")] void __stdcall CCall2([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2);
		[entry("CCall3")] void __stdcall CCall3([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3);
		[entry("CCall4")] void __stdcall CCall4([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4);
		[entry("CCall5")] void __stdcall CCall5([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4, void* a5);
		[entry("CCall6")] void __stdcall CCall6([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4, void* a5, void* a6);
		[entry("CCall7")] void __stdcall CCall7([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4, void* a5, void* a6, void* a7);
		[entry("CCall8")] void __stdcall CCall8([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4, void* a5, void* a6, void* a7, void* a8);
		[entry("CCall9")] void __stdcall CCall9([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4, void* a5, void* a6, void* a7, void* a8, void* a9);
		[entry("CCall10")] void __stdcall CCall10([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2, void* a3, void* a4, void* a5, void* a6, void* a7, void* a8, void* a9, void* a10);
		[entry("Call2_"), helpstring("Экспериментальная версия")] 
			void __stdcall Call2_([in] __int3264 fn, [in, out] void* ret, [in] int retSz, void* a1, void* a2);
		//void __stdcall Call2([in] __int3264 fn, [in, out] void* ret, [in] int retSz, [in, optional, defaultvalue(NullPtr)] void* arg1, [in, optional, defaultvalue(NullPtr)] void* arg2);
	};
	
	[
		dllname("Kernel32.dll"),
		helpstring("Library Functions"),
		hidden
	]
	module kernel32{
		[entry("LoadLibraryW")]
		__int3264 __stdcall LoadLibW( [in] BSTR LibFileName );
		[entry("FreeLibrary")]
		long FreeLib( [in] __int3264 hLibModule );
		[entry("GetProcAddress")]
		__int3264 __stdcall GetProcAddr( [in] __int3264 hModule, [in] BSTR AnsiProcName );
		[entry("RtlMoveMemory")]
		void __stdcall CopyMem([in, out] void* dst, [in] const void* src, __int3264 sz);
	};
};